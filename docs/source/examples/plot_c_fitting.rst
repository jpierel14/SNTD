
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/plot_c_fitting.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_plot_c_fitting.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_plot_c_fitting.py:


===================
Measure Time Delays
===================

A series of examples demonstrating various fitting options/features
with SNTD.

.. GENERATED FROM PYTHON SOURCE LINES 11-25

There are 3 methods built into SNTD to measure time delays
(parallel, series, color). They are accessed by the same 
function: :py:func:`~sntd.fitting.fit_data` . 
Here ``myMISN`` was generated in the :ref:`sphx_glr_examples_plot_b_sim.py` part 
of the documentation, using the :py:func:`~sntd.simulation.createMultiplyImagedSN` 
function. The true delay for all of these fits is 50 days.
You can batch process (with sbatch or multiprocessing) using any or all of these methods as well 
(see :ref:`examples:Batch Processing Time Delay Measurements`)

------------------------------------------------------------------------------------------------------------------------------------------
`Run this notebook with Google Colab <https://colab.research.google.com/github/jpierel14/sntd/blob/master/notebooks/docs_fitting.ipynb>`_.
------------------------------------------------------------------------------------------------------------------------------------------

**Parallel:**

.. GENERATED FROM PYTHON SOURCE LINES 25-41

.. code-block:: default

    import sntd

    myMISN=sntd.load_example_misn()

    fitCurves=sntd.fit_data(myMISN,snType='Ia', models='salt2-extended',bands=['F110W','F160W'],
                    params=['x0','t0','x1','c'],constants={'z':1.4},refImage='image_1',cut_time=[-30,40],
                    bounds={'t0':(-20,20),'x1':(-2,2),'c':(-1,1),'mu':(.5,2)},fitOrder=['image_1','image_2'],
                    method='parallel',microlensing=None,modelcov=False,npoints=100)
    print(fitCurves.parallel.time_delays)
    print(fitCurves.parallel.time_delay_errors)
    print(fitCurves.parallel.magnifications)
    print(fitCurves.parallel.magnification_errors)
    fitCurves.plot_object(showFit=True,method='parallel')
    fitCurves.plot_fit(method='parallel',par_image='image_1')
    fitCurves.plot_fit(method='parallel',par_image='image_2')




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /examples/images/sphx_glr_plot_c_fitting_001.png
          :alt: Multiply-Imaged SN "My Type Ia SN"--HST
          :class: sphx-glr-multi-img

    *

      .. image:: /examples/images/sphx_glr_plot_c_fitting_002.png
          :alt: t0 = ${19.24}_{-0.50}^{+0.50}$, x0 = ${0.00}_{-0.00}^{+0.00}$, x1 = ${-2.69}_{-0.30}^{+0.40}$, c = ${-0.09}_{-0.04}^{+0.04}$
          :class: sphx-glr-multi-img

    *

      .. image:: /examples/images/sphx_glr_plot_c_fitting_003.png
          :alt: t0 = ${69.70}_{-0.98}^{+1.04}$, x0 = ${0.00}_{-0.00}^{+0.00}$, x1 = ${-1.95}_{-0.03}^{+0.14}$, c = ${-0.08}_{-0.02}^{+0.02}$
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'image_1': 0, 'image_2': 50.442299642467276}
    {'image_1': array([0, 0]), 'image_2': array([-0.95826261,  0.98199374])}
    {'image_1': 1, 'image_2': 0.4998899592804862}
    {'image_1': array([0, 0]), 'image_2': array([-0.02284181,  0.02404375])}

    <Figure size 970x970 with 16 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 42-48

Note that the bounds for the 't0' parameter are not absolute, the actual peak time will be estimated (unless t0_guess is defined)
and the defined bounds will be added to this value. Similarly for amplitude, where bounds are multiplicative

Other methods are called in a similar fashion, with a couple of extra arguments:

**Series:**

.. GENERATED FROM PYTHON SOURCE LINES 48-63

.. code-block:: default



    fitCurves=sntd.fit_data(myMISN,snType='Ia', models='salt2-extended',bands=['F110W','F160W'],
            params=['x0','t0','x1','c'],constants={'z':1.4},refImage='image_1',cut_time=[-30,40],
            bounds={'t0':(-20,20),'td':(-20,20),'mu':(.5,2),'x1':(-2,2),'c':(-.5,.5)},
            method='series',npoints=100)
        

    print(fitCurves.series.time_delays)
    print(fitCurves.series.time_delay_errors)
    print(fitCurves.series.magnifications)
    print(fitCurves.series.magnification_errors)
    fitCurves.plot_object(showFit=True,method='series')
    fitCurves.plot_fit(method='series')




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /examples/images/sphx_glr_plot_c_fitting_004.png
          :alt: Multiply-Imaged SN "My Type Ia SN"--HST
          :class: sphx-glr-multi-img

    *

      .. image:: /examples/images/sphx_glr_plot_c_fitting_005.png
          :alt: x0 = ${0.00}_{-0.00}^{+0.00}$, t0 = ${19.33}_{-0.61}^{+0.56}$, x1 = ${-1.90}_{-0.08}^{+0.13}$, c = ${-0.09}_{-0.02}^{+0.02}$, dt_2 = ${50.40}_{-0.82}^{+0.73}$, mu_2 = ${0.55}_{-0.01}^{+0.02}$
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ['x0', 't0', 'x1', 'c']
    ['x0', 't0', 'x1', 'c']
    {'image_1': 0, 'image_2': 50.39797715147582}
    {'image_1': array([0, 0]), 'image_2': array([-0.82216382,  0.72853045])}
    {'image_1': 1, 'image_2': 0.5515560895917695}
    {'image_1': 1, 'image_2': array([-0.01397073,  0.01642504])}

    <Figure size 1390x1390 with 36 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 64-68

**Color:**
By default, this will attempt to fit every combination of colors possible from
the bands present in the data. You can define specific colors using the "fit_colors"
argument.

.. GENERATED FROM PYTHON SOURCE LINES 68-81

.. code-block:: default



    
    fitCurves=sntd.fit_data(myMISN,snType='Ia', models='salt2-extended',bands=['F110W','F160W'],
                        params=['t0','c'],constants={'z':1.4,'x1':fitCurves.images['image_1'].fits.model.get('x1')},refImage='image_1',
                        color_param_ignore=['x1'],bounds={'t0':(-20,20),'td':(-20,20),'mu':(.5,2),'c':(-.5,.5)},cut_time=[-30,40],
                        method='color',microlensing=None,modelcov=False,npoints=200,maxiter=None,minsnr=3)

    print(fitCurves.color.time_delays)
    print(fitCurves.color.time_delay_errors)
    fitCurves.plot_object(showFit=True,method='color')
    fitCurves.plot_fit(method='color')




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /examples/images/sphx_glr_plot_c_fitting_006.png
          :alt: Multiply-Imaged SN "My Type Ia SN"--HST
          :class: sphx-glr-multi-img

    *

      .. image:: /examples/images/sphx_glr_plot_c_fitting_007.png
          :alt: t0 = ${16.50}_{-2.54}^{+2.98}$, c = ${-0.13}_{-0.04}^{+0.03}$, dt_2 = ${51.54}_{-5.35}^{+5.19}$
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'image_1': 0, 'image_2': 51.530224748944036}
    {'image_1': array([0, 0]), 'image_2': array([-5.35065195,  5.19171365])}

    <Figure size 760x760 with 9 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 82-83

You can include your fit from the parallel method as a prior on light curve and time delay parameters in the series/color methods with the "fit_prior" command:

.. GENERATED FROM PYTHON SOURCE LINES 83-101

.. code-block:: default




    fitCurves_parallel=sntd.fit_data(myMISN,snType='Ia', models='salt2-extended',bands=['F110W','F160W'],
                    	params=['x0','t0','x1','c'],constants={'z':1.4},refImage='image_1',
                    	bounds={'t0':(-20,20),'x1':(-3,3),'c':(-.5,.5),'mu':(.5,2)},fitOrder=['image_1','image_2'],cut_time=[-30,40],
                   	    method='parallel',microlensing=None,modelcov=False,npoints=100,maxiter=None)
    fitCurves_color=sntd.fit_data(myMISN,snType='Ia', models='salt2-extended',bands=['F110W','F160W'],cut_time=[-50,30],
                    	params=['t0','c'],constants={'z':1.4,'x1':fitCurves.images['image_1'].fits.model.get('x1')},refImage='image_1',
                    	bounds={'t0':(-20,20),'td':(-20,20),'mu':(.5,2),'c':(-.5,.5)},fit_prior=fitCurves_parallel,
                    	method='color',microlensing=None,modelcov=False,npoints=200,maxiter=None,minsnr=3)

    print(fitCurves_parallel.parallel.time_delays)
    print(fitCurves_parallel.parallel.time_delay_errors)
    print(fitCurves_color.color.time_delays)
    print(fitCurves_color.color.time_delay_errors)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'image_1': 0, 'image_2': 50.096483213906325}
    {'image_1': array([0, 0]), 'image_2': array([-0.99028586,  1.26368148])}
    {'image_1': 0, 'image_2': 50.31747986433648}
    {'image_1': array([0, 0]), 'image_2': array([-2.01481246,  2.28440021])}




.. GENERATED FROM PYTHON SOURCE LINES 102-107

**Fitting Using Extra Propagation Effects**

You might also want to include other propagation effects in your fitting model, and fit relevant parameters. This can be done by
simply adding effects to an SNCosmo model, in the same way as if you were fitting a single SN with SNCosmo. First we can add some
extreme dust in the source and lens frames (your final simulations may look slightly different as **c** is chosen randomly):

.. GENERATED FROM PYTHON SOURCE LINES 107-118

.. code-block:: default




    myMISN2 = sntd.createMultiplyImagedSN(sourcename='salt2-extended', snType='Ia', redshift=1.4,z_lens=.53, bands=['F110W','F160W'],
                  zp=[26.9,26.2], cadence=8., epochs=30.,time_delays=[20., 70.], magnifications=[20,10],
                  objectName='My Type Ia SN',telescopename='HST',av_lens=1.5,
                  av_host=1)
    print('lensebv:',myMISN2.images['image_1'].simMeta['lensebv'],
         'hostebv:',myMISN2.images['image_1'].simMeta['hostebv'], 
         'c:',myMISN2.images['image_1'].simMeta['c'])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    lensebv: 0.48387096774193544 hostebv: 0.3225806451612903 c: 0.1377735187090485




.. GENERATED FROM PYTHON SOURCE LINES 119-120

Okay, now we can fit the MISN first without taking these effects into account:

.. GENERATED FROM PYTHON SOURCE LINES 120-131

.. code-block:: default




    fitCurves_dust=sntd.fit_data(myMISN2,snType='Ia', models='salt2-extended',bands=['F110W','F160W'],
                                                         params=['x0','x1','t0','c'],npoints=200,
                                                         constants={'z':1.4},minsnr=1,cut_time=[-30,40],
                                                         bounds={'t0':(-15,15),'x1':(-3,3),'c':(-1,1)})
    print(fitCurves_dust.parallel.time_delays)
    print(fitCurves_dust.parallel.time_delay_errors)
    print('c:',fitCurves_dust.images['image_1'].fits.model.get('c'))
    fitCurves_dust.plot_object(showFit=True)



.. image:: /examples/images/sphx_glr_plot_c_fitting_008.png
    :alt: Multiply-Imaged SN "My Type Ia SN"--HST
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'image_1': 0, 'image_2': 50.412287698579206}
    {'image_1': array([0, 0]), 'image_2': array([-0.74964906,  0.72983875])}
    c: 0.8117704098202272

    <Figure size 1000x1000 with 2 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 132-135

We can see that the fitter has done reasonably well, and the time delay is still accurate (True delay is 50 days). 
However, one issue is that the measured value for **c** is vastly different than the actual value 
as it attempts to compensate for extinction without a propagation effect. Now let's add in the propagation effects:

.. GENERATED FROM PYTHON SOURCE LINES 135-150

.. code-block:: default


    import sncosmo
    dust = sncosmo.CCM89Dust()
    salt2_model=sncosmo.Model('salt2-extended',effects=[dust,dust],effect_names=['lens','host'],effect_frames=['free','rest'])
    fitCurves_dust=sntd.fit_data(myMISN2,snType='Ia', models=salt2_model,bands=['F110W','F160W'],npoints=200,
                        params=['x0','x1','t0','c','lensebv','hostebv'],minsnr=1,cut_time=[-30,40],
                        constants={'z':1.4,'lensr_v':3.1,'lensz':0.53,'hostr_v':3.1},
                        bounds={'t0':(-15,15),'x1':(-3,3),'c':(-.1,.1),'lensebv':(.2,1.),'hostebv':(.2,1.)})

    print(fitCurves_dust.parallel.time_delays)
    print(fitCurves_dust.parallel.time_delay_errors)
    print('c:',fitCurves_dust.images['image_1'].fits.model.get('c'),
          'lensebv:',fitCurves_dust.images['image_1'].fits.model.get('lensebv'),
          'hostebv:',fitCurves_dust.images['image_1'].fits.model.get('hostebv'))
    fitCurves_dust.plot_object(showFit=True)



.. image:: /examples/images/sphx_glr_plot_c_fitting_009.png
    :alt: Multiply-Imaged SN "My Type Ia SN"--HST
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'image_1': 0, 'image_2': 50.33052950846436}
    {'image_1': array([0, 0]), 'image_2': array([-0.65493107,  0.68273663])}
    c: -0.30174440537013747 lensebv: -0.6076719364812484 hostebv: 1.5424337700970974

    <Figure size 1000x1000 with 2 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 151-153

Now the measured value for **c** is much closer to reality, and the measured times of peak are somewhat
more accurate. 


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  57.033 seconds)


.. _sphx_glr_download_examples_plot_c_fitting.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_c_fitting.py <plot_c_fitting.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_c_fitting.ipynb <plot_c_fitting.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
